# CHEMIN : D:\EMIT\DA2I\BOSY\L3\S6\STAGE\STAGE_ITDC\APPLICATION\backend\app\routers\authority.py

from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks
from typing import List
from ..database.database import supabase
from ..utils.dependencies import role_checker
from ..schemas.incidents import IncidentResponse # Le modèle de réponse est déjà correct
from ..schemas.users import UserResponse
from ..utils.email_sender import send_assignment_to_security
from uuid import UUID

router = APIRouter()

get_current_authority_user = role_checker("AUTORITE_LOCALE")

def log_status_change(incident_id: int, old_status: str, new_status: str, user_id: UUID):
    """Enregistre un changement de statut dans la table historiquestatuts."""
    try:
        supabase.table("historiquestatuts").insert({
            "incident_id": incident_id,
            "ancien_statut": old_status,
            "nouveau_statut": new_status,
            "modifie_par_id": user_id
        }).execute()
    except Exception as e:
        # En production, il serait préférable d'utiliser un logger
        print(f"ERROR logging status change for incident {incident_id}: {e}")

@router.get("/incidents/pending",
            response_model=List[IncidentResponse],
            summary="Lister les incidents en attente de validation") 
def get_pending_incidents(current_user: UserResponse = Depends(get_current_authority_user)): 
    """
    Récupère tous les incidents qui nécessitent une action ('NOUVEAU' ou 'URGENT').
    Cette route inclut désormais les données jointes du Fokontany et du Type d'incident.
    """ 
    try:
        # ✅ ASTUCE APPLIQUÉE : La requête est modifiée pour imiter celle de la route de détail.
        # "*, fokontany(*), typesincident(*)" demande à Supabase :
        # - '*' : toutes les colonnes de la table `incidents`.
        # - 'fokontany(*)' : l'objet complet de la table `fokontany` liée.
        # - 'typesincident(*)' : l'objet complet de la table `typesincident` liée.
        query = "*, fokontany(*), typesincident(*)"

        # La requête est maintenant correcte
        response = supabase.table("incidents").select(query).in_("statut", ["NOUVEAU", "URGENT"]).order("date_signalement", desc=True).execute()
        
        return response.data 
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e)) 

# ... Le reste de votre fichier authority.py n'a pas besoin de changer ...

@router.post("/incidents/{incident_id}/validate",
             response_model=IncidentResponse,
             summary="Valider un incident")
def validate_incident(incident_id: int, current_user: UserResponse = Depends(get_current_authority_user)):
    """Change le statut d'un incident de 'NOUVEAU' ou 'URGENT' à 'VALIDE'."""
    try:
        incident_to_validate_res = supabase.table("incidents").select("statut").eq("id", incident_id).in_("statut", ["NOUVEAU", "URGENT"]).single().execute()
        if not incident_to_validate_res.data:
            raise HTTPException(status_code=404, detail="Incident non trouvé, déjà traité ou ne peut être validé.")

        old_status = incident_to_validate_res.data['statut']
        
        # On met à jour l'incident
        response = supabase.table("incidents").update({"statut": "VALIDE"}).eq("id", incident_id).select("*").single().execute()
        if not response.data:
            raise HTTPException(status_code=404, detail="La validation de l'incident a échoué.")

        log_status_change(incident_id, old_status, "VALIDE", current_user.id)
        return response.data
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/incidents/{incident_id}/reject",
             response_model=IncidentResponse,
             summary="Rejeter un incident")
def reject_incident(incident_id: int, current_user: UserResponse = Depends(get_current_authority_user)):
    """Change le statut d'un incident de 'NOUVEAU' ou 'URGENT' à 'REJETE'."""
    try:
        incident_to_reject_res = supabase.table("incidents").select("statut").eq("id", incident_id).in_("statut", ["NOUVEAU", "URGENT"]).single().execute()
        if not incident_to_reject_res.data:
            raise HTTPException(status_code=404, detail="Incident non trouvé, déjà traité ou ne peut être rejeté.")

        old_status = incident_to_reject_res.data['statut']
        response = supabase.table("incidents").update({"statut": "REJETE"}).eq("id", incident_id).select("*").single().execute()
        if not response.data:
            raise HTTPException(status_code=404, detail="Le rejet de l'incident a échoué.")

        log_status_change(incident_id, old_status, "REJETE", current_user.id)
        return response.data
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/incidents/{incident_id}/assign/{agent_id}",
             response_model=IncidentResponse,
             summary="Assigner un incident à un agent")
def assign_incident(
    incident_id: int,
    agent_id: UUID,
    background_tasks: BackgroundTasks,
    current_user: UserResponse = Depends(get_current_authority_user)
):
    """Change le statut à 'ASSIGNE' et lie l'incident à un agent de sécurité."""
    from datetime import datetime
    
    # Étape 1 : Valider l'incident (le passer à 'VALIDE')
    try:
        validate_res = supabase.table("incidents").select("statut").eq("id", incident_id).in_("statut", ["NOUVEAU", "URGENT"]).single().execute()
        if not validate_res.data:
             raise HTTPException(status_code=404, detail="L'incident à assigner est introuvable ou a déjà été traité.")
        
        old_status_before_validation = validate_res.data['statut']
        
        validated_incident_res = supabase.table("incidents").update({"statut": "VALIDE"}).eq("id", incident_id).select("*").single().execute()
        if not validated_incident_res.data:
             raise HTTPException(status_code=400, detail="Échec de la validation préalable à l'assignation.")
        
        log_status_change(incident_id, old_status_before_validation, "VALIDE", current_user.id)

        # Étape 2 : Assigner l'incident maintenant qu'il est 'VALIDE'
        update_data = {
            "statut": "ASSIGNE",
            "assigne_a_id": agent_id,
            "date_assignation": datetime.now().isoformat()
        }
        
        assign_response = supabase.table("incidents").update(update_data).eq("id", incident_id).eq("statut", "VALIDE").select("*, typesincident(*), fokontany(*)").single().execute()
        
        if not assign_response.data:
            raise HTTPException(status_code=404, detail="Échec de l'assignation. L'incident n'a pas pu être trouvé avec le statut 'VALIDE'.")

        assigned_incident = assign_response.data
        log_status_change(incident_id, "VALIDE", "ASSIGNE", current_user.id)

        # Envoyer l'email en tâche de fond
        agent_response = supabase.table("utilisateurs").select("email").eq("id", agent_id).single().execute()
        if agent_response.data:
            agent_email = agent_response.data['email']
            background_tasks.add_task(
                send_assignment_to_security,
                agent_email=agent_email,
                incident_title=assigned_incident['titre'],
                incident_id=assigned_incident['id']
            )

        return assigned_incident

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))